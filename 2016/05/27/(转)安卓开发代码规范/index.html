<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>从0开始学习Markdown | 坚持</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文内容转自
Android Project Guidelines
Android Project Guidelines
The aim of this document is to define project guidelines. These should be followed throughout the Android project in order to help us to ke">
<meta property="og:type" content="article">
<meta property="og:title" content="从0开始学习Markdown">
<meta property="og:url" content="http://www.lqs1993.cc/2016/05/27/(转)安卓开发代码规范/index.html">
<meta property="og:site_name" content="坚持">
<meta property="og:description" content="本文内容转自
Android Project Guidelines
Android Project Guidelines
The aim of this document is to define project guidelines. These should be followed throughout the Android project in order to help us to ke">
<meta property="og:updated_time" content="2016-08-26T09:31:35.884Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从0开始学习Markdown">
<meta name="twitter:description" content="本文内容转自
Android Project Guidelines
Android Project Guidelines
The aim of this document is to define project guidelines. These should be followed throughout the Android project in order to help us to ke">
  
    <link rel="alternative" href="/atom.xml" title="坚持" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img.woyaogexing.com/2016/03/14/5eb6808df1d180b4!200x200.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">QingSong</a></h1>
		</hgroup>

		
		<p class="header-subtitle">第一个博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/学习笔记/" style="font-size: 20px;">学习笔记</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">QingSong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://img.woyaogexing.com/2016/03/14/5eb6808df1d180b4!200x200.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">QingSong</h1>
			</hgroup>
			
			<p class="header-subtitle">第一个博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-(转)安卓开发代码规范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/(转)安卓开发代码规范/" class="article-date">
  	<time datetime="2016-05-27T03:10:20.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从0开始学习Markdown
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文内容转自</p>
<p><a href="https://github.com/bufferapp/android-guidelines/blob/master/project_style_guidelines.md" target="_blank" rel="external"><strong>Android Project Guidelines</strong></a></p>
<h1 id="Android-Project-Guidelines"><a href="#Android-Project-Guidelines" class="headerlink" title="Android Project Guidelines"></a>Android Project Guidelines</h1><hr>
<p>The aim of this document is to define project guidelines. These should be followed throughout the Android project in order to help us to keep our code base clean and consistent. A lot of this will be enforced by code quality checks through Jenkins, but it’s important to be mindful of the things that may not be picked up 🙂</p>
<h2 id="1-Project-Guidelines"><a href="#1-Project-Guidelines" class="headerlink" title="1. Project Guidelines"></a>1. Project Guidelines</h2><h3 id="1-1-Project-Structure"><a href="#1-1-Project-Structure" class="headerlink" title="1.1 Project Structure"></a>1.1 Project Structure</h3><p>When contributing work, the project should maintain the following structure:</p>
<pre><code>src/androidTest
src/test
src/commonTest
src/main
</code></pre><p><strong>androidTest</strong> - Directory containing functional tests<br><strong>test</strong> - Directory containing unit tests<br><strong>commonTest</strong> - Directory containing shared test code for AndroidTest &amp; Test<br><strong>main</strong> - Directory containing application code</p>
<p>The structure of the project should remain as defined above whenever you are modifying or adding new features.</p>
<p>Using this structure allows us to keep the application code seperated from any test-related code. The CommonTest directory allows us to share classes between the functional and unit tests, such as mock model creation and dagger test configuration classes.</p>
<h3 id="1-2-File-Naming"><a href="#1-2-File-Naming" class="headerlink" title="1.2 File Naming"></a>1.2 File Naming</h3><h4 id="1-2-1-Class-Files"><a href="#1-2-1-Class-Files" class="headerlink" title="1.2.1 Class Files"></a>1.2.1 Class Files</h4><p>Any classes that you define should be named using UpperCamelCase, for example:</p>
<pre><code>AndroidActivity, NetworkHelper, UserFragment, PerActivity
</code></pre><p>Any classes extending an Android framework component should <strong>always</strong> end with the component name. For example:</p>
<pre><code>UserFragment, SignUpActivity, RateAppDialog, PushNotificationServer, NumberView
</code></pre><p>We use UpperCamelCase as this helps to seperate the words used to create the name, making it easier to read. Naming classes to end with the framework component makes it super clear as to what the class is used for. For example, if you’re looking to make changes to the RegistrationDialog then this naming convention makes it really easy to locate that class.</p>
<h4 id="1-2-1-Resource-Files"><a href="#1-2-1-Resource-Files" class="headerlink" title="1.2.1 Resource Files"></a>1.2.1 Resource Files</h4><p>When naming resource files you should be sure to name them using lowercase letters and underscores instead of spaces, for example:</p>
<pre><code>activity_main, fragment_user, item_post
</code></pre><p>This convention again makes it really easy to locate the specific layout file that you’re looking for. Within android studio, the layout package is sorted in alphabetical order meaning that activity, fragment and other layout types becomes grouped - so you know where to begin looking for a file. Other than this, begining the file name with the component name makes it clear what component/class the layout file is being used for.</p>
<h4 id="1-2-2-1-Drawable-Files"><a href="#1-2-2-1-Drawable-Files" class="headerlink" title="1.2.2.1 Drawable Files"></a>1.2.2.1 Drawable Files</h4><p>Drawable resource files should be named using the <strong>ic_</strong> prefix along with the size and color of the asset. For example, white accept icon sized at 24dp would be named:</p>
<pre><code>ic_accept_24dp_white
</code></pre><p>And a black cancel icon sized at 48dp would be named:</p>
<pre><code>ic_cancel_48dp_black
</code></pre><p>We use this naming convention so that a drawable file is recognisable by its name. If the colour and size are not stated in the name, then the developer needs to open the drawable file to find out this information. This saves us a little bit of time :)</p>
<p>Other drawable files should be named using the corresponding prefix, for example:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Prefix</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Selector</td>
<td>selector_</td>
<td>selector_button_cancel</td>
</tr>
<tr>
<td>Background</td>
<td>bg_</td>
<td>bg_rounded_button</td>
</tr>
<tr>
<td>Circle</td>
<td>circle_</td>
<td>circle_white</td>
</tr>
<tr>
<td>Progress</td>
<td>progress_</td>
<td>progress_circle_purple</td>
</tr>
<tr>
<td>Divider</td>
<td>divider_</td>
<td>divider_grey</td>
</tr>
</tbody>
</table>
<p>This convention again helps to group similar items within Android Studio. It also makes it clear as to what the item is used for. For example, naming a resource button_cancel could mean anything! Is this a selector resource or a rounded button background? Correct naming helps to clear any ambiguity that may arise.</p>
<p>When creating selector state resources, they should be named using the corresponding suffix:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Suffix</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal</td>
<td>_normal</td>
<td>btn_accept_normal</td>
</tr>
<tr>
<td>Pressed</td>
<td>_pressed</td>
<td>btn_accept_pressed</td>
</tr>
<tr>
<td>Focused</td>
<td>_focused</td>
<td>btn_accept_focused</td>
</tr>
<tr>
<td>Disabled</td>
<td>_disabled</td>
<td>btn_accept_disabled</td>
</tr>
<tr>
<td>Selected</td>
<td>_selected</td>
<td>btn_accept_selected</td>
</tr>
</tbody>
</table>
<p>Using clear prefixes such as the above helps to make it absolutely obvious as to what a selector state resource is used for. Prefixing resources with the colour or any other identifier again requires the developer to open the selector file to be educated in what the different selector state resources are.</p>
<h4 id="1-2-2-2-Layout-Files"><a href="#1-2-2-2-Layout-Files" class="headerlink" title="1.2.2.2 Layout Files"></a>1.2.2.2 Layout Files</h4><p>When naming layout files, they should be named starting with the name of the Android Component that they have been created for. For example:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Class Name</th>
<th>Layout Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td>MainActivity</td>
<td>activity_main</td>
</tr>
<tr>
<td>Fragment</td>
<td>MainFragment</td>
<td>fragment_main</td>
</tr>
<tr>
<td>Dialog</td>
<td>RateDialog</td>
<td>dialog_rate</td>
</tr>
<tr>
<td>Widget</td>
<td>UserProfileView</td>
<td>view_user_profile</td>
</tr>
<tr>
<td>AdapterView Item</td>
<td>N/A</td>
<td>item_follower</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> If you create a layout using the merge tag then the layout_ prefix should be used.</p>
<p>Not only does this approach makes it easy to find files in the directory hierarchy, but it really helps when needing to identify what corresponding class a layout file belongs to.</p>
<h4 id="1-2-2-3-Menu-Files"><a href="#1-2-2-3-Menu-Files" class="headerlink" title="1.2.2.3 Menu Files"></a>1.2.2.3 Menu Files</h4><p>Menu files do not need to be prefixed with the menu_ prefix. This is because they are already in the menu package in the resources directory, so it is not a requirement.</p>
<h4 id="1-2-2-4-Values-Files"><a href="#1-2-2-4-Values-Files" class="headerlink" title="1.2.2.4 Values Files"></a>1.2.2.4 Values Files</h4><p>All resource file names should be plural, for example:</p>
<pre><code>attrs.xml, strings.xml, styles.xml, colors.xml, dimens.xml
</code></pre><h2 id="2-Code-Guidelines"><a href="#2-Code-Guidelines" class="headerlink" title="2. Code Guidelines"></a>2. Code Guidelines</h2><h3 id="2-1-Java-Language-Rules"><a href="#2-1-Java-Language-Rules" class="headerlink" title="2.1 Java Language Rules"></a>2.1 Java Language Rules</h3><h4 id="2-1-1-Never-ignore-exceptions"><a href="#2-1-1-Never-ignore-exceptions" class="headerlink" title="2.1.1 Never ignore exceptions"></a>2.1.1 Never ignore exceptions</h4><p>Avoid not handling exceptions in the correct manner. For example:</p>
<pre><code>public void setUserId(String id) {
    try {
        mUserId = Integer.parseInt(id);
    } catch (NumberFormatException e) { }
}
</code></pre><p>This gives no information to both the developer and the user, making it harder to debug and could also leave the user confused if something goes wrong. When catching an exception, we should also always log the error to the console for debugging purposes and if necessary alert the user of the issue. For example:</p>
<pre><code>public void setCount(String count) {
    try {
        count = Integer.parseInt(id);
    } catch (NumberFormatException e) {
        count = 0;
        Log.e(TAG, &quot;There was an error parsing the count &quot; + e);
        DialogFactory.showErrorMessage(R.string.error_message_parsing_count);
    }
}
</code></pre><p>Here we handle the error appropriately by:</p>
<ul>
<li>Showing a message to the user notifying them that there has been an error</li>
<li>Setting a default value for the variable if possible</li>
<li>Throw an appropriate exception</li>
</ul>
<h4 id="2-1-2-Never-catch-generic-exceptions"><a href="#2-1-2-Never-catch-generic-exceptions" class="headerlink" title="2.1.2 Never catch generic exceptions"></a>2.1.2 Never catch generic exceptions</h4><p>Catching exceptions generally should not be done:</p>
<pre><code>public void openCustomTab(Context context, Uri uri) {
    Intent intent = buildIntent(context, uri);
    try {
        context.startActivity(intent);
    } catch (Exception e) {
        Log.e(TAG, &quot;There was an error opening the custom tab &quot; + e);
    }
}
</code></pre><p>Why?</p>
<p><em>Do not do this. In almost all cases it is inappropriate to catch generic Exception or Throwable (preferably not Throwable because it includes Error exceptions). It is very dangerous because it means that Exceptions you never expected (including RuntimeExceptions like ClassCastException) get caught in application-level error handling. It obscures the failure handling properties of your code, meaning if someone adds a new type of Exception in the code you’re calling, the compiler won’t help you realize you need to handle the error differently. In most cases you shouldn’t be handling different types of exception the same way.</em> - taken from the Android Code Style Guidelines</p>
<p>Instead, catch the expected exception and handle it accordingly:</p>
<pre><code>public void openCustomTab(Context context, Uri uri) {
    Intent intent = buildIntent(context, uri);
    try {
        context.startActivity(intent);
    } catch (ActivityNotFoundException e) {
        Log.e(TAG, &quot;There was an error opening the custom tab &quot; + e);
    }
}
</code></pre><h4 id="2-1-3-Grouping-exceptions"><a href="#2-1-3-Grouping-exceptions" class="headerlink" title="2.1.3 Grouping exceptions"></a>2.1.3 Grouping exceptions</h4><p>Where exceptions execute the same code, they should be grouped in-order to increase readability and avoid code duplication. For example, where you may do this:</p>
<pre><code>public void openCustomTab(Context context, @Nullable Uri uri) {
    Intent intent = buildIntent(context, uri);
    try {
        context.startActivity(intent);
    } catch (ActivityNotFoundException e) {
        Log.e(TAG, &quot;There was an error opening the custom tab &quot; + e);
    } catch (NullPointerException e) {
        Log.e(TAG, &quot;There was an error opening the custom tab &quot; + e);
    } catch (SomeOtherException e) {
        // Show some dialog
    }
}
</code></pre><p>You could do this:</p>
<pre><code>public void openCustomTab(Context context, @Nullable Uri uri) {
    Intent intent = buildIntent(context, uri);
    try {
        context.startActivity(intent);
    } catch (ActivityNotFoundException e | NullPointerException e) {
        Log.e(TAG, &quot;There was an error opening the custom tab &quot; + e);
    } catch (SomeOtherException e) {
        // Show some dialog
    }
}
</code></pre><h4 id="2-1-4-Using-try-catch-over-throw-exception"><a href="#2-1-4-Using-try-catch-over-throw-exception" class="headerlink" title="2.1.4 Using try-catch over throw exception"></a>2.1.4 Using try-catch over throw exception</h4><p>Using try-catch statements improves the readability of the code where the exception is taking place. This is because the error is handled where it occurs, making it easier to both debug or make a change to how the error is handled.</p>
<h4 id="2-1-5-Never-use-Finalizers"><a href="#2-1-5-Never-use-Finalizers" class="headerlink" title="2.1.5 Never use Finalizers"></a>2.1.5 Never use Finalizers</h4><p><em>There are no guarantees as to when a finalizer will be called, or even that it will be called at all. In most cases, you can do what you need from a finalizer with good exception handling. If you absolutely need it, define a close() method (or the like) and document exactly when that method needs to be called. See InputStreamfor an example. In this case it is appropriate but not required to print a short log message from the finalizer, as long as it is not expected to flood the logs.</em> - taken from the Android code style guidelines</p>
<h4 id="2-1-6-Fully-qualify-imports"><a href="#2-1-6-Fully-qualify-imports" class="headerlink" title="2.1.6 Fully qualify imports"></a>2.1.6 Fully qualify imports</h4><p>When declaring imports, use the full package declaration. For example:</p>
<p>Don’t do this:</p>
<pre><code>import android.support.v7.widget.*;
</code></pre><p>Instead, do this 😃</p>
<pre><code>import android.support.v7.widget.RecyclerView;
</code></pre><h4 id="2-1-7-Don’t-keep-unused-imports"><a href="#2-1-7-Don’t-keep-unused-imports" class="headerlink" title="2.1.7 Don’t keep unused imports"></a>2.1.7 Don’t keep unused imports</h4><p>Sometimes removing code from a class can mean that some imports are no longer needed. If this is the case then the corresponding imports should be removed alongside the code.</p>
<h3 id="2-2-Java-Style-Rules"><a href="#2-2-Java-Style-Rules" class="headerlink" title="2.2 Java Style Rules"></a>2.2 Java Style Rules</h3><h4 id="2-2-1-Field-definition-and-naming"><a href="#2-2-1-Field-definition-and-naming" class="headerlink" title="2.2.1 Field definition and naming"></a>2.2.1 Field definition and naming</h4><p>All fields should be declared at the top of the file, following these rules:</p>
<ul>
<li><p>Private, non-static field names should not start with m. This is right:</p>
<p>  userSignedIn, userNameText, acceptButton</p>
</li>
</ul>
<p>Not this:</p>
<pre><code>mUserSignedIn, mUserNameText, mAcceptButton
</code></pre><ul>
<li><p>Private, static field names do not need to start with an s. This is right:</p>
<p>  someStaticField, userNameText</p>
</li>
</ul>
<p>Not this:</p>
<pre><code>sSomeStaticField, sUserNameText
</code></pre><ul>
<li>All other fields also start with a lower case letter.</li>
</ul>
<pre><code>int numOfChildren;
String username;
</code></pre><ul>
<li>Static final fields (known as constants) are ALL_CAPS_WITH_UNDERSCORES.</li>
</ul>
<pre><code>private static final int PAGE_COUNT = 0;
</code></pre><p>Field names that do not reveal intention should not be used. For example,</p>
<pre><code>int e; //number of elements in the list
</code></pre><p>why not just give the field a meaningful name in the first place, rather than leaving a comment!</p>
<pre><code>int numberOfElements;
</code></pre><p>That’s much better!</p>
<h4 id="2-2-1-2-View-Field-Naming"><a href="#2-2-1-2-View-Field-Naming" class="headerlink" title="2.2.1.2 View Field Naming"></a>2.2.1.2 View Field Naming</h4><p>When naming fields that reference views, the name of the view should be the last word in the name. For example:</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>TextView</td>
<td>usernameView</td>
</tr>
<tr>
<td>Button</td>
<td>acceptLoginView</td>
</tr>
<tr>
<td>ImageView</td>
<td>profileAvatarView</td>
</tr>
<tr>
<td>RelativeLayout</td>
<td>profileLayout</td>
</tr>
</tbody>
</table>
<p>We name views in this way so that we can easily identify what the field corresponds to. For example, having a field named <strong>user</strong> is extremely ambiguous - giving it the name usernameView, userAvatarView or userProfieLayout helps to make it clear  exactly what view the field corresponds with.</p>
<p>Previously, the names for views often ended in the view type (e.g acceptLoginButton) but quite often views change and it’s easy to forgot to go back to java classes and update variable names.</p>
<h4 id="2-2-2-Avoid-naming-with-container-types"><a href="#2-2-2-Avoid-naming-with-container-types" class="headerlink" title="2.2.2 Avoid naming with container types"></a>2.2.2 Avoid naming with container types</h4><p>Leading on from the above, we should also avoid the use of container type names when creating variables for collections. For example, say we have an arraylist containing a list of userIds:</p>
<p>Do:</p>
<pre><code>List&lt;String&gt; userIds = new ArrayList&lt;&gt;();
</code></pre><p>Don’t:</p>
<pre><code>List&lt;String&gt; userIdList = new ArrayList&lt;&gt;();
</code></pre><p>If and when container names change in the future, the naming of these can often get forgotten about - and just like view naming, it’s not entirely necessary. Correct naming of the container itself should provide enough information for what it is.</p>
<h4 id="2-2-3-Avoid-similar-naming"><a href="#2-2-3-Avoid-similar-naming" class="headerlink" title="2.2.3 Avoid similar naming"></a>2.2.3 Avoid similar naming</h4><p>Naming variables, method and / or classes with similar names can make it confusing for other developers reading over your code. For example:</p>
<pre><code>hasUserSelectedSingleProfilePreviously

hasUserSelectedSignedProfilePreviously
</code></pre><p>Distinguishing the difference between these at a first glance can be hard to understand what is what. Naming these in a clearer way can make it easier for developers to navigate the fields in your code.</p>
<h4 id="2-2-4-Number-series-naming"><a href="#2-2-4-Number-series-naming" class="headerlink" title="2.2.4 Number series naming"></a>2.2.4 Number series naming</h4><p>When Android Studio auto-generates code for us, it’s easy to leave things as they are - even when it generate horribly named parameters! For example, this isn’t very nice:</p>
<pre><code>public void doSomething(String s1, String s2, String s3)
</code></pre><p>It’s hard to understand what these parameters do without reading the code. Instead:</p>
<pre><code>public void doSomething(String userName, String userEmail, String userId)
</code></pre><p>That makes it much easier to understand! Now we’ll be able to read the code following the parameter with a much clearer understanding 🙂</p>
<h4 id="2-2-5-Pronouncable-names"><a href="#2-2-5-Pronouncable-names" class="headerlink" title="2.2.5 Pronouncable names"></a>2.2.5 Pronouncable names</h4><p>When naming fields, methods and classes they should:</p>
<ul>
<li><p>Be readable: Efficient naming means we’ll be able to look at the name and understand it instantly, reducing cognitive load on trying to decipher what the name means.</p>
</li>
<li><p>Be speakable: Names that are speakable avoids awkward conversations where you’re trying to pronounce a badly named variable name.</p>
</li>
<li><p>Be searchable: Nothing is worse than trying to search for a method or variable in a class to realise it’s been spelt wrong or badly named. If we’re trying to find a method that searches for a user, then searching for ‘search’ should bring up a result for that method.</p>
</li>
<li><p>Not use Hungarian notation: Hungarian notation goes against the three points made above, so it should never be used!</p>
</li>
</ul>
<h4 id="2-2-6-Treat-acronyms-as-words"><a href="#2-2-6-Treat-acronyms-as-words" class="headerlink" title="2.2.6 Treat acronyms as words"></a>2.2.6 Treat acronyms as words</h4><p>Any acronyms for class names, variable names etc should be treated as words - this applies for any capitalisation used for any of the letters. For example:</p>
<table>
<thead>
<tr>
<th>Do</th>
<th>Don’t</th>
</tr>
</thead>
<tbody>
<tr>
<td>setUserId</td>
<td>setUserID</td>
</tr>
<tr>
<td>String uri</td>
<td>String URI</td>
</tr>
<tr>
<td>int id</td>
<td>int ID</td>
</tr>
<tr>
<td>parseHtml</td>
<td>parseHTML</td>
</tr>
<tr>
<td>generateXmlFile</td>
<td>generateXMLFile</td>
</tr>
</tbody>
</table>
<h4 id="2-2-7-Avoid-justifying-variable-declarations"><a href="#2-2-7-Avoid-justifying-variable-declarations" class="headerlink" title="2.2.7 Avoid justifying variable declarations"></a>2.2.7 Avoid justifying variable declarations</h4><p>Any declaration of variables should not use any special form of alignment, for example:</p>
<p>This is fine:</p>
<pre><code>private int userId = 8;
private int count = 0;
private String username = &quot;hitherejoe&quot;;
</code></pre><p>Avoid doing this:</p>
<pre><code>private String username = &quot;hitherejoe&quot;;
private int userId      = 8;
private int count       = 0;
</code></pre><p>This creates a stream of whitespace which is known to make text difficult to read for certain learning difficulties.</p>
<h4 id="2-2-8-Use-spaces-for-indentation"><a href="#2-2-8-Use-spaces-for-indentation" class="headerlink" title="2.2.8 Use spaces for indentation"></a>2.2.8 Use spaces for indentation</h4><p>For blocks, 4 space indentation should be used:</p>
<pre><code>if (userSignedIn) {
    count = 1;
}
</code></pre><p>Whereas for line wraps, 8 spaces should be used:</p>
<pre><code>String userAboutText =
        &quot;This is some text about the user and it is pretty long, can you see!&quot;
</code></pre><h3 id="2-2-9-If-Statements"><a href="#2-2-9-If-Statements" class="headerlink" title="2.2.9 If-Statements"></a>2.2.9 If-Statements</h3><h4 id="2-2-9-1-Use-standard-brace-style"><a href="#2-2-9-1-Use-standard-brace-style" class="headerlink" title="2.2.9.1 Use standard brace style"></a>2.2.9.1 Use standard brace style</h4><p>Braces should always be used on the same line as the code before them. For example, avoid doing this:</p>
<pre><code>class SomeClass
{
    private void someFunction()
    {
        if (isSomething)
        {

        }
        else if (!isSomethingElse)
        {

        }
        else
        {

        }
    }
}
</code></pre><p>And instead, do this:</p>
<pre><code>class SomeClass {
    private void someFunction() {
        if (isSomething) {

        } else if (!isSomethingElse) {

        } else {

        }
    }
}
</code></pre><p>Not only is the extra line for the space not really necessary, but it makes blocks easier to follow when reading the code.</p>
<h4 id="2-2-9-2-Inline-if-clauses"><a href="#2-2-9-2-Inline-if-clauses" class="headerlink" title="2.2.9.2 Inline if-clauses"></a>2.2.9.2 Inline if-clauses</h4><p>Sometimes it makes sense to use a single line for if statements. For example:</p>
<pre><code>if (user == null) return false;
</code></pre><p>However, it only works for simple operations. Something like this would be better suited with braces:</p>
<pre><code>if (user == null) throw new IllegalArgumentExeption(&quot;Oops, user object is required.&quot;);
</code></pre><h4 id="2-2-9-3-Nested-if-conditions"><a href="#2-2-9-3-Nested-if-conditions" class="headerlink" title="2.2.9.3 Nested if-conditions"></a>2.2.9.3 Nested if-conditions</h4><p>Where possible, if-conditions should be combined to avoid over-complicated nesting. For example:</p>
<p>Do:</p>
<pre><code>if (userSignedIn &amp;&amp; userId != null) {

}
</code></pre><p>Try to avoid:</p>
<pre><code>if (userSignedIn) {
    if (userId != null) {

    }
}
</code></pre><p>This makes statements easier to read and removes the unnecessary extra lines from the nested clauses.</p>
<h4 id="2-2-9-4-Ternary-Operators"><a href="#2-2-9-4-Ternary-Operators" class="headerlink" title="2.2.9.4 Ternary Operators"></a>2.2.9.4 Ternary Operators</h4><p>Where appropriate, ternary operators can be used to simplify operations.</p>
<p>For example, this is easy to read:</p>
<pre><code>userStatusImage = signedIn ? R.drawable.ic_tick : R.drawable.ic_cross;
</code></pre><p>and takes up far fewer lines of code than this:</p>
<pre><code>if (signedIn) {
    userStatusImage = R.drawable.ic_tick;
} else {
    userStatusImage = R.drawable.ic_cross;
}
</code></pre><p><strong>Note:</strong> There are some times when ternary operators should not be used. If the if-clause logic is complex or a large number of characters then a standard brace style should be used.</p>
<h3 id="2-2-10-Annotations"><a href="#2-2-10-Annotations" class="headerlink" title="2.2.10 Annotations"></a>2.2.10 Annotations</h3><h4 id="2-2-10-1-Annotation-practices"><a href="#2-2-10-1-Annotation-practices" class="headerlink" title="2.2.10.1 Annotation practices"></a>2.2.10.1 Annotation practices</h4><p>Taken from  the Android code style guide:</p>
<p><strong>@Override:</strong> The @Override annotation must be used whenever a method overrides the declaration or implementation from a super-class. For example, if you use the @inheritdocs Javadoc tag, and derive from a class (not an interface), you must also annotate that the method @Overrides the parent class’s method.</p>
<p><strong>@SuppressWarnings:</strong> The @SuppressWarnings annotation should only be used under circumstances where it is impossible to eliminate a warning. If a warning passes this “impossible to eliminate” test, the @SuppressWarnings annotation must be used, so as to ensure that all warnings reflect actual problems in the code.</p>
<p>More information about annotation guidelines can be found here.</p>
<hr>
<p>Annotations should always be used where possible. For example, using the @Nullable annotation should be used in cases where a field could be expected as null. For example:</p>
<pre><code>@Nullable TextView userNameText;

private void getName(@Nullable String name) { }
</code></pre><h4 id="2-2-10-2-Annotation-style"><a href="#2-2-10-2-Annotation-style" class="headerlink" title="2.2.10.2 Annotation style"></a>2.2.10.2 Annotation style</h4><p>Annotations that are applied to a method or class should always be defined in the declaration, with only one per line:</p>
<pre><code>@Annotation
@AnotherAnnotation
public class SomeClass {

  @SomeAnotation
  public String getMeAString() {

  }

}
</code></pre><p>When using the annotations on fields, you should ensure that the annotation remains on the same line whilst there is room. For example:</p>
<pre><code>@Bind(R.id.layout_coordinator) CoordinatorLayout coordinatorLayout;


@Inject MainPresenter mainPresenter;
</code></pre><p>We do this as it makes the statement easier to read. For example, the statement ‘@Inject SomeComponent mSomeName’ reads as ‘inject this component with this name’.</p>
<h4 id="2-2-11-Limit-variable-scope"><a href="#2-2-11-Limit-variable-scope" class="headerlink" title="2.2.11 Limit variable scope"></a>2.2.11 Limit variable scope</h4><p>The scope of local variables should be kept to a minimum (Effective Java Item 29). By doing so, you increase the readability and maintainability of your code and reduce the likelihood of error. Each variable should be declared in the innermost block that encloses all uses of the variable.</p>
<p>Local variables should be declared at the point they are first used. Nearly every local variable declaration should contain an initializer. If you don’t yet have enough information to initialize a variable sensibly, you should postpone the declaration until you do. - taken from the Android code style guidelines</p>
<h4 id="2-2-12-Unused-elements"><a href="#2-2-12-Unused-elements" class="headerlink" title="2.2.12 Unused elements"></a>2.2.12 Unused elements</h4><p>All unused <strong>fields</strong>, <strong>imports</strong>, <strong>methods</strong> and <strong>classes</strong> should be removed from the code base unless there is any specific reasoning behind keeping it there.</p>
<h4 id="2-2-13-Order-Import-Statements"><a href="#2-2-13-Order-Import-Statements" class="headerlink" title="2.2.13 Order Import Statements"></a>2.2.13 Order Import Statements</h4><p>Because we use Android Studio, so imports should always be ordered automatically. However, in the case that they may not be, then they should be ordered as follows:</p>
<ol>
<li>Android imports</li>
<li>Imports from third parties</li>
<li>java and javax imports</li>
<li>Imports from the current Project</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Imports should be alphabetically ordered within each grouping, with capital letters before lower case letters (e.g. Z before a)</li>
<li>There should be a blank line between each major grouping (android, com, JUnit, net, org, java, javax)</li>
</ul>
<h4 id="2-2-14-Logging"><a href="#2-2-14-Logging" class="headerlink" title="2.2.14 Logging"></a>2.2.14 Logging</h4><p>Logging should be used to log useful error messages and/or other information that may be useful during development.</p>
<table>
<thead>
<tr>
<th>Log</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Log.v(String tag, String message)</td>
<td>verbose</td>
</tr>
<tr>
<td>Log.d(String tag, String message)</td>
<td>debug</td>
</tr>
<tr>
<td>Log.i(String tag, String message)</td>
<td>information</td>
</tr>
<tr>
<td>Log.w(String tag, String message)</td>
<td>warning</td>
</tr>
<tr>
<td>Log.e(String tag, String message)</td>
<td>error</td>
</tr>
</tbody>
</table>
<p>We can set the <code>Tag</code> for the log as a <code>static final</code> field at the top of the class, for example:</p>
<pre><code>private static final String TAG = MyActivity.class.getName();
</code></pre><p>All verbose and debug logs must be disabled on release builds. On the other hand - information, warning and error logs should only be kept enabled if deemed necessary.</p>
<pre><code>if (BuildConfig.DEBUG) {
    Log.d(TAG, &quot;Here&apos;s a log message&quot;);
}
</code></pre><p><strong>Note:</strong> Timber is the preferred logging method to be used. It handles the tagging for us, which saves us keeping a reference to a TAG.</p>
<h4 id="2-2-15-Field-Ordering"><a href="#2-2-15-Field-Ordering" class="headerlink" title="2.2.15 Field Ordering"></a>2.2.15 Field Ordering</h4><p>Any fields declared at the top of a class file should be ordered in the following order:</p>
<ol>
<li>Enums</li>
<li>Constants</li>
<li>Dagger Injected fields</li>
<li>Butterknife View Bindings</li>
<li>private global variables</li>
<li>public global variables</li>
</ol>
<p>For example:</p>
<pre><code>public static enum {
    ENUM_ONE, ENUM_TWO
}

public static final String KEY_NAME = &quot;KEY_NAME&quot;;
public static final int COUNT_USER = 0;

@Inject SomeAdapter someAdapter;

@BindView(R.id.text_name) TextView nameText;
@BindView(R.id.image_photo) ImageView photoImage;

private int userCount;
private String errorMessage;

public int someCount;
public String someString;
</code></pre><p>Using this ordering convention helps to keep field declarations grouped, which increases both the locating of and readability of said fields.</p>
<h4 id="2-2-16-Class-member-ordering"><a href="#2-2-16-Class-member-ordering" class="headerlink" title="2.2.16 Class member ordering"></a>2.2.16 Class member ordering</h4><p>To improve code readability, it’s important to organise class members in a logical manner. The following order should be used to achieve this:</p>
<ol>
<li>Constants</li>
<li>Fields</li>
<li>Constructors</li>
<li>Override methods and callbacks (public or private)</li>
<li>Public methods</li>
<li>Private methods</li>
<li>Inner classes or interfaces</li>
</ol>
<p>For example:</p>
<pre><code>public class MainActivity extends Activity {

    private int count;

    public static newInstance() { }

    @Override
    public void onCreate() { }

    public setUsername() { }

    private void setupUsername() { }

    static class AnInnerClass { }

    interface SomeInterface { }

}
</code></pre><p>Any lifecycle methods used in Android framework classes should be ordered in the corresponding lifecycle order. For example:</p>
<pre><code>public class MainActivity extends Activity {

    // Field and constructors

    @Override
    public void onCreate() { }

    @Override
    public void onStart() { }

    @Override
    public void onResume() { }

    @Override
    public void onPause() { }

    @Override
    public void onStop() { }

    @Override
    public void onRestart() { }

    @Override
    public void onDestroy() { }

    // public methods, private methods, inner classes and interfaces

}
</code></pre><h4 id="2-2-17-Method-parameter-ordering"><a href="#2-2-17-Method-parameter-ordering" class="headerlink" title="2.2.17 Method parameter ordering"></a>2.2.17 Method parameter ordering</h4><p>When defining methods, parameters should be ordered to the following convention:</p>
<pre><code>public Post loadPost(Context context, int postId);


public void loadPost(Context context, int postId, Callback callback);
</code></pre><p><strong>Context</strong> parameters always go first and <strong>Callback</strong> parameters always go last.</p>
<h4 id="2-2-18-String-constants-naming-and-values"><a href="#2-2-18-String-constants-naming-and-values" class="headerlink" title="2.2.18 String constants, naming, and values"></a>2.2.18 String constants, naming, and values</h4><p>When using string constants, they should be declared as final static and use the follow conventions:</p>
<p>[Strings table]</p>
<h4 id="2-2-19-Enums"><a href="#2-2-19-Enums" class="headerlink" title="2.2.19 Enums"></a>2.2.19 Enums</h4><p>Enums should only be used where actually required. If another method is possible, then that should be the preferred way of approaching the implementation. For example:</p>
<p>Instead of this:</p>
<pre><code>public enum SomeEnum {
    ONE, TWO, THREE
}
</code></pre><p>Do this:</p>
<pre><code>private static final int VALUE_ONE = 1;
private static final int VALUE_TWO = 2;
private static final int VALUE_THREE = 3;
</code></pre><h4 id="2-2-20-Arguments-in-fragments-and-activities"><a href="#2-2-20-Arguments-in-fragments-and-activities" class="headerlink" title="2.2.20 Arguments in fragments and activities"></a>2.2.20 Arguments in fragments and activities</h4><p>When we pass data using an Intent or Bundle, the keys for the values must use the conventions defined below:</p>
<p><strong>Activity</strong></p>
<p>Passing data to an activity must be done using a reference to a KEY, as defined as below:</p>
<pre><code>private static final String KEY_NAME = &quot;com.your.package.name.to.activity.KEY_NAME&quot;;
</code></pre><p><strong>Fragment</strong></p>
<p>Passing data to a fragment must be done using a reference to an EXTRA, as defined as below:</p>
<pre><code>private static final String EXTRA_NAME = &quot;EXTRA_NAME&quot;;
</code></pre><p>When creating new instances of a fragment or activity that involves passing data, we should provide a static method to retrieve the new instance, passing the data as method parameters. For example:</p>
<p><strong>Activity</strong></p>
<pre><code>public static Intent getStartIntent(Context context, Post post) {
    Intent intent = new Intent(context, CurrentActivity.class);
    intent.putParcelableExtra(EXTRA_POST, post);
    return intent;
}
</code></pre><p><strong>Fragment</strong></p>
<pre><code>public static PostFragment newInstance(Post post) {
    PostFragment fragment = new PostFragment();
    Bundle args = new Bundle();
    args.putParcelable(ARGUMENT_POST, post);
    fragment.setArguments(args)
    return fragment;
}
</code></pre><h4 id="2-2-21-Line-Length-Limit"><a href="#2-2-21-Line-Length-Limit" class="headerlink" title="2.2.21 Line Length Limit"></a>2.2.21 Line Length Limit</h4><p>Code lines should exceed no longer than 100 characters, this makes the code more readable. Sometimes to achieve this, we may need to:</p>
<ul>
<li>Extract data to a local variable</li>
<li>Extract logic to an external method</li>
<li>Line-wrap code to separate a single line of code to multiple lines</li>
</ul>
<p><strong>Note:</strong> For code comments and import statements it’s ok to exceed the 100 character limit.</p>
<h4 id="2-2-21-1-Line-wrapping-techniques"><a href="#2-2-21-1-Line-wrapping-techniques" class="headerlink" title="2.2.21.1 Line-wrapping techniques"></a>2.2.21.1 Line-wrapping techniques</h4><p>When it comes to line-wraps, there’s a few situations where we should be consistent in the way we format code.</p>
<p><strong>Breaking at Operators</strong></p>
<p>When we need to break a line at an operator, we break the line before the operator:</p>
<pre><code>int count = countOne + countTwo - countThree + countFour * countFive - countSix
        + countOnANewLineBecauseItsTooLong;
</code></pre><p>If desirable, you can always break after the <code>=</code> sign:</p>
<pre><code>int count =
        countOne + countTwo - countThree + countFour * countFive + countSix;
</code></pre><p><strong>Method Chaining</strong></p>
<p>When it comes to method chaining, each method call should be on a new line.</p>
<p>Don’t do this:</p>
<pre><code>Picasso.with(context).load(&quot;someUrl&quot;).into(imageView);
</code></pre><p>Instead, do this:</p>
<pre><code>Picasso.with(context)
        .load(&quot;someUrl&quot;)
        .into(imageView);
</code></pre><p><strong>Long Parameters</strong></p>
<p>In the case that a method contains long parameters, we should line break where appropriate. For example when declaring a method we should break after the last comma of the parameter that fits:</p>
<pre><code>private void someMethod(Context context, String someLongStringName, String text,
                            long thisIsALong, String anotherString) {               
}             
</code></pre><p>And when calling that method we should break after the comma of each parameter:</p>
<pre><code>someMethod(context,
        &quot;thisIsSomeLongTextItsQuiteLongIsntIt&quot;,
        &quot;someText&quot;,
        01223892365463456,
        &quot;thisIsSomeLongTextItsQuiteLongIsntIt&quot;);
</code></pre><h4 id="2-2-22-Method-spacing"><a href="#2-2-22-Method-spacing" class="headerlink" title="2.2.22 Method spacing"></a>2.2.22 Method spacing</h4><p>There only needs to be a single line space between methods in a class, for example:</p>
<p>Do this:</p>
<pre><code>public String getUserName() {
    // Code
}

public void setUserName(String name) {
    // Code
}

public boolean isUserSignedIn() {
    // Code
}
</code></pre><p>Not this:</p>
<pre><code>public String getUserName() {
    // Code
}


public void setUserName(String name) {
    // Code
}


public boolean isUserSignedIn() {
    // Code
}
</code></pre><h3 id="2-2-23-Comments"><a href="#2-2-23-Comments" class="headerlink" title="2.2.23 Comments"></a>2.2.23 Comments</h3><h4 id="2-2-23-1-Inline-comments"><a href="#2-2-23-1-Inline-comments" class="headerlink" title="2.2.23.1 Inline comments"></a>2.2.23.1 Inline comments</h4><p>Where necessary, inline comments should be used to provide a meaningful description to the reader on what a specific piece of code does. They should only be used in situations where the code may be complex to understand. In most cases however, code should be written in a way that it easy to understand without comments 🙂</p>
<p><strong>Note:</strong> Code comments do not have to, but should try to, stick to the 100 character rule.</p>
<h4 id="2-2-23-2-JavaDoc-Style-Comments"><a href="#2-2-23-2-JavaDoc-Style-Comments" class="headerlink" title="2.2.23.2 JavaDoc Style Comments"></a>2.2.23.2 JavaDoc Style Comments</h4><p>Whilst a method name should usually be enough to communicate a methods functionality, it can sometimes help to provide JavaDoc style comments. This helps the reader to easily understand the methods functionality, as well as the purpose of any parameters that are being passed into the method.</p>
<pre><code>/**
 * Authenticates the user against the API given a User id.
 * If successful, this returns a success result
 *
 * @param userId The user id of the user that is to be authenticated.
 */
</code></pre><h4 id="2-2-23-3-Class-comments"><a href="#2-2-23-3-Class-comments" class="headerlink" title="2.2.23.3 Class comments"></a>2.2.23.3 Class comments</h4><p>When creating class comments they should be meaningful and descriptive, using links where necessary. For example:</p>
<pre><code>/**
  * RecyclerView adapter to display a list of {@link Post}.
  * Currently used with {@link PostRecycler} to show the list of Post items.
  */
</code></pre><p>Don’t leave author comments, these aren’t useful and provide no real meaningful information when multiple people are to be working on the class.</p>
<pre><code>/**
  * Created By Joe 18/06/2016
  */
</code></pre><h3 id="2-2-24-Sectioning-code"><a href="#2-2-24-Sectioning-code" class="headerlink" title="2.2.24 Sectioning code"></a>2.2.24 Sectioning code</h3><h4 id="2-2-24-1-Java-code"><a href="#2-2-24-1-Java-code" class="headerlink" title="2.2.24.1 Java code"></a>2.2.24.1 Java code</h4><p>If creating ‘sections’ for code, this should be done using the following approach, like this:</p>
<pre><code>public void method() { }

public void someOtherMethod() { }

/********* Mvp Method Implementations  ********/

public void anotherMethod() { }

/********* Helper Methods  ********/

public void someMethod() { }
</code></pre><p>Not like this:</p>
<pre><code>public void method() { }

public void someOtherMethod() { }

// Mvp Method Implementations

public void anotherMethod() { }
</code></pre><p>This makes sectioned methods easier to located in a class.</p>
<h4 id="2-2-24-2-Strings-file"><a href="#2-2-24-2-Strings-file" class="headerlink" title="2.2.24.2 Strings file"></a>2.2.24.2 Strings file</h4><p>String resources defined within the string.xml file should be section by feature, for example:</p>
<pre><code>// User Profile Activity
&lt;string name=&quot;button_save&quot;&gt;Save&lt;/string&gt;
&lt;string name=&quot;button_cancel&quot;&gt;Cancel&lt;/string&gt;

// Settings Activity
&lt;string name=&quot;message_instructions&quot;&gt;...&lt;/string&gt;
</code></pre><p>Not only does this help keep the strings file tidy, but it makes it easier to find strings when they need altering.</p>
<h4 id="2-2-24-3-RxJava-chaining"><a href="#2-2-24-3-RxJava-chaining" class="headerlink" title="2.2.24.3 RxJava chaining"></a>2.2.24.3 RxJava chaining</h4><p>When chaining Rx operations, every operator should be on a new line, breaking the line before the period <code>.</code> . For example:</p>
<pre><code>return dataManager.getPost()
            .concatMap(new Func1&lt;Post, Observable&lt;? extends Post&gt;&gt;() {
                @Override
                 public Observable&lt;? extends Post&gt; call(Post post) {
                     return mRetrofitService.getPost(post.id);
                 }
            })
            .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() {
                 @Override
                 public Boolean call(Integer numRetries, Throwable throwable) {
                     return throwable instanceof RetrofitError;
                 }
            });
</code></pre><p>This makes it easier to understand the flow of operation within an Rx chain of calls.</p>
<h3 id="2-2-25-Butterknife"><a href="#2-2-25-Butterknife" class="headerlink" title="2.2.25 Butterknife"></a>2.2.25 Butterknife</h3><h4 id="2-2-25-1-Event-listeners"><a href="#2-2-25-1-Event-listeners" class="headerlink" title="2.2.25.1 Event listeners"></a>2.2.25.1 Event listeners</h4><p>Where possible, make use of Butterknife listener bindings. For example, when listening for a click event instead of doing this:</p>
<pre><code>mSubmitButton.setOnClickListener(new View.OnClickListener() {
    public void onClick(View v) {
        // Some code here...
    }
  };
</code></pre><p>Do this:</p>
<pre><code>@OnClick(R.id.button_submit)
public void onSubmitButtonClick() { }
</code></pre><h2 id="2-3-XML-Style-Rules"><a href="#2-3-XML-Style-Rules" class="headerlink" title="2.3 XML Style Rules"></a>2.3 XML Style Rules</h2><h3 id="2-3-1-Use-self-closing-tags"><a href="#2-3-1-Use-self-closing-tags" class="headerlink" title="2.3.1 Use self=-closing tags"></a>2.3.1 Use self=-closing tags</h3><p>When a View in an XML layout does not have any child views, self-closing tags should be used.</p>
<p>Do:</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/image_user&quot;
    android:layout_width=&quot;90dp&quot;
    android:layout_height=&quot;90dp&quot; /&gt;
</code></pre><p>Don’t:</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/image_user&quot;
    android:layout_width=&quot;90dp&quot;
    android:layout_height=&quot;90dp&quot;&gt;
&lt;/ImageView&gt;
</code></pre><h3 id="2-3-2-Resource-naming"><a href="#2-3-2-Resource-naming" class="headerlink" title="2.3.2 Resource naming"></a>2.3.2 Resource naming</h3><p>All resource names and IDs should be written using lowercase and underscores, for example:</p>
<pre><code>text_username, activity_main, fragment_user, error_message_network_connection
</code></pre><p>The main reason for this is consistency, it also makes it easier to search for views within layout files when it comes to altering the contents of the file.</p>
<h4 id="2-3-2-1-ID-naming"><a href="#2-3-2-1-ID-naming" class="headerlink" title="2.3.2.1 ID naming"></a>2.3.2.1 ID naming</h4><p>All IDs should be prefixed using the name of the element that they have been declared for.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td>ImageView</td>
<td>image_</td>
</tr>
<tr>
<td>Fragment</td>
<td>fragment_</td>
</tr>
<tr>
<td>RelativeLayout</td>
<td>layout_</td>
</tr>
<tr>
<td>Button</td>
<td>button_</td>
</tr>
<tr>
<td>TextView</td>
<td>text_</td>
</tr>
<tr>
<td>View</td>
<td>view_</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<pre><code>&lt;TextView
    android:id=&quot;@+id/text_username&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;
</code></pre><p>Views that typically are only one per layout, such as a toolbar, can simply be given the id of it’s view type. E.g.<code>toolbar</code>.</p>
<h4 id="2-3-2-2-Strings"><a href="#2-3-2-2-Strings" class="headerlink" title="2.3.2.2 Strings"></a>2.3.2.2 Strings</h4><p>All string names should begin with a prefix for the part of the application that they are being referenced from. For example:</p>
<table>
<thead>
<tr>
<th>Screen</th>
<th>String</th>
<th>Resource Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Registration Fragment</td>
<td>“Register now”</td>
<td>registration_register_now</td>
</tr>
<tr>
<td>Sign Up Activity</td>
<td>“Cancel”</td>
<td>sign_up_cancel</td>
</tr>
<tr>
<td>Rate App Dialog</td>
<td>“No thanks”</td>
<td>rate_app_no_thanks</td>
</tr>
</tbody>
</table>
<p>If it’s not possible to name the referenced like the above, we can use the following rules:</p>
<table>
<thead>
<tr>
<th>Prefix</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>error_</td>
<td>Used for error messages</td>
</tr>
<tr>
<td>title_</td>
<td>Used for dialog titles</td>
</tr>
<tr>
<td>action_</td>
<td>Used for option menu actions</td>
</tr>
<tr>
<td>msg_</td>
<td>Used for generic message such as in a dialog</td>
</tr>
<tr>
<td>label_</td>
<td>Used for activity labels</td>
</tr>
</tbody>
</table>
<p>Two important things to note for String resources:</p>
<ul>
<li><p>String resources should never be reused across screens. This can cause issues when it comes to changing a string for a specific screen. It saves future complications by having a single string for each screens usage.</p>
</li>
<li><p>String resources should <strong>always</strong> be defined in the strings file and never hardcoded in layout or class files.</p>
</li>
</ul>
<h4 id="2-3-2-3-Styles-and-themes"><a href="#2-3-2-3-Styles-and-themes" class="headerlink" title="2.3.2.3 Styles and themes"></a>2.3.2.3 Styles and themes</h4><p>When defining both Styles &amp; Themes, they should be named using UpperCamelCase. For example:</p>
<pre><code>AppTheme.DarkBackground.NoActionBar
AppTheme.LightBackground.TransparentStatusBar

ProfileButtonStyle
TitleTextStyle
</code></pre><h3 id="2-3-3-Attributes-ordering"><a href="#2-3-3-Attributes-ordering" class="headerlink" title="2.3.3 Attributes ordering"></a>2.3.3 Attributes ordering</h3><p>Ordering attributes not only looks tidy but it helps to make it quicker when looking for attributes within layout files. As a general rule,</p>
<ol>
<li>View Id</li>
<li>Style</li>
<li>Layout width and layout height</li>
<li>Other <code>layout_</code> attributes, sorted alphabetically</li>
<li>Remaining attributes, sorted alphabetically</li>
</ol>
<p>For example:</p>
<pre><code>&lt;Button
    android:id=&quot;@id/button_accept&quot;
    style=&quot;@style/ButtonStyle&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_alignParentBottom=&quot;true&quot;
    android:layout_alignParentStart=&quot;true&quot;
    android:padding=&quot;16dp&quot;
    android:text=&quot;@string/button_skip_sign_in&quot;
    android:textColor=&quot;@color/bluish_gray&quot; /&gt;
</code></pre><p>Note: This formatting can be carried out by using the format feature in android studio -</p>
<p><code>cmd + shift + L</code></p>
<p>Doing this makes it easy to navigate through XML attributes when it comes to making changes to layout files.</p>
<h2 id="2-4-Tests-style-rules"><a href="#2-4-Tests-style-rules" class="headerlink" title="2.4 Tests style rules"></a>2.4 Tests style rules</h2><h3 id="2-4-1-Unit-tests"><a href="#2-4-1-Unit-tests" class="headerlink" title="2.4.1 Unit tests"></a>2.4.1 Unit tests</h3><p>Any Unit Test classes should be written to match the name of the class that the test are targeting, followed by the Test suffix. For example:</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Test Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataManager</td>
<td>DataManagerTest</td>
</tr>
<tr>
<td>UserProfilePresenter</td>
<td>UserProfilePresenterTest</td>
</tr>
<tr>
<td>PreferencesHelper</td>
<td>PreferencesHelperTest</td>
</tr>
</tbody>
</table>
<p>All Test methods should be annotated with the <code>@Test</code> annotation, the methods should be named using the following template:</p>
<pre><code>@Test
public void methodNamePreconditionExpectedResult() { }
</code></pre><p>So for example, if we want to check that the signUp() method with an invalid email address fails, the test would look like:</p>
<pre><code>@Test
public void signUpWithInvalidEmailFails() { }
</code></pre><p>Tests should focus on testing only what the method name entitles, if there’s extra conditions being tested in your Test method then this should be moved to it’s own individual test.</p>
<p>If a class we are testing contains many different methods, then the tests should be split across multiple test classes - this helps to keep the tests more maintainable and easier to locate. For example, a DatabaseHelper class may need to be split into multiple test classes such as :</p>
<pre><code>DatabaseHelperUserTest
DatabaseHelperPostsTest
DatabaseHelperDraftsTest
</code></pre><h3 id="2-4-2-Espresso-tests"><a href="#2-4-2-Espresso-tests" class="headerlink" title="2.4.2 Espresso tests"></a>2.4.2 Espresso tests</h3><p>Each Espresso test class generally targets an Activity, so the name given to it should match that of the targeted Activity, again followed by Test. For example:</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Test Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>MainActivity</td>
<td>MainActivityTest</td>
</tr>
<tr>
<td>ProfileActivity</td>
<td>ProfileActivityTest</td>
</tr>
<tr>
<td>DraftsActivity</td>
<td>DraftsActivityTest</td>
</tr>
</tbody>
</table>
<p>When using the Espresso API, methods should be chained on new lines to make the statements more readable, for example:</p>
<pre><code>onView(withId(R.id.text_title))
        .perform(scrollTo())
        .check(matches(isDisplayed()))
</code></pre><p>Chaining calls in this style not only helps us stick to less than 100 characters per line but it also makes it easy to read the chain of events taking place in espresso tests.</p>
<h1 id="3-Gradle-Style"><a href="#3-Gradle-Style" class="headerlink" title="3. Gradle Style"></a>3. Gradle Style</h1><h2 id="3-1-Dependencies"><a href="#3-1-Dependencies" class="headerlink" title="3.1 Dependencies"></a>3.1 Dependencies</h2><h3 id="3-1-1-Versioning"><a href="#3-1-1-Versioning" class="headerlink" title="3.1.1 Versioning"></a>3.1.1 Versioning</h3><p>Where applicable, versioning that is shared across multiple dependencies should be defined as a variable within the dependencies scope. For example:</p>
<pre><code>final SUPPORT_LIBRARY_VERSION = &apos;23.4.0&apos;

compile &quot;com.android.support:support-v4:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:recyclerview-v7:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:support-annotations:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:design:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:percent:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:customtabs:$SUPPORT_LIBRARY_VERSION&quot;
</code></pre><p>This makes it easy to update dependencies in the future as we only need to change the version number once for multiple dependencies.</p>
<h3 id="3-1-2-Grouping"><a href="#3-1-2-Grouping" class="headerlink" title="3.1.2 Grouping"></a>3.1.2 Grouping</h3><p>Where applicable, dependencies should be grouped by package name, with spaces in-between the groups. For example:</p>
<pre><code>compile &quot;com.android.support:percent:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:customtabs:$SUPPORT_LIBRARY_VERSION&quot;

compile &apos;io.reactivex:rxandroid:1.2.0&apos;
compile &apos;io.reactivex:rxjava:1.1.5&apos;

compile &apos;com.jakewharton:butterknife:7.0.1&apos;
compile &apos;com.jakewharton.timber:timber:4.1.2&apos;

compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;
</code></pre><p><code>compile</code> , <code>testCompile</code> and <code>androidTestCompile</code>  dependencies should also be grouped into their corresponding section. For example:</p>
<pre><code>// App Dependencies
compile &quot;com.android.support:support-v4:$SUPPORT_LIBRARY_VERSION&quot;
compile &quot;com.android.support:recyclerview-v7:$SUPPORT_LIBRARY_VERSION&quot;

// Instrumentation test dependencies
androidTestCompile &quot;com.android.support:support-annotations:$SUPPORT_LIBRARY_VERSION&quot;

// Unit tests dependencies
testCompile &apos;org.robolectric:robolectric:3.0&apos;
</code></pre><p>Both of these approaches makes it easy to locate specific dependencies when required as it keeps dependency declarations both clean and tidy 🙌</p>
<h3 id="3-1-3-Independent-Dependencies"><a href="#3-1-3-Independent-Dependencies" class="headerlink" title="3.1.3 Independent Dependencies"></a>3.1.3 Independent Dependencies</h3><p>Where dependencies are only used individually for application or test purposes, be sure to only compile them using <code>compile</code> , <code>testCompile</code> or <code>androidTestCompile</code> . For example, where the robolectric dependency is only required for unit tests, it should be added using:</p>
<pre><code>testCompile &apos;org.robolectric:robolectric:3.0&apos;
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/07/RxAndroid-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          RxJava 学习笔记 1
        
      </div>
    </a>
  
  
    <a href="/2016/05/27/Hexo-Git-Build a personal blog/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hexo+Git 搭建个人博客</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>




<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="(转)安卓开发代码规范" data-title="从0开始学习Markdown" data-url="http://www.lqs1993.cc/2016/05/27/(转)安卓开发代码规范/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ZhanShen"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 QingSong
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>